<!DOCTYPE html>
<html lang="az">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pasyak Reels</title>
    <style>
        * {
            outline: none !important;
            box-shadow: none !important;
            -webkit-tap-highlight-color: transparent;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        html,
        body {
            height: 100%;
            background: #121212FF;
            overflow: hidden;
            font-family: Arial, sans-serif;
            color: white;
        }

        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #121212FF;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .spinner {
            border: 4px solid #333;
            border-top: 4px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        #app {
            height: 100vh;
            width: 100vw;
            position: relative;
            overflow: hidden;
            background: #121212FF;
            scroll-behavior: smooth;
            touch-action: none;
        }

        .reel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #121212FF;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transform: translateY(100%);
            transition: transform 0.5s ease, opacity 0.5s ease;
            pointer-events: none;
        }

        .reel.active {
            opacity: 1;
            transform: translateY(0);
            z-index: 2;
            pointer-events: auto;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #121212FF;
            user-select: none;
            cursor: pointer;
            display: none;
        }

        .reel-loader {
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        .overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 16px;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8) 30%, transparent 100%);
            z-index: 3;
            color: white;
            display: flex;
            flex-direction: column;
        }

        .profile-info {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .user-info {
            display: flex;
            align-items: center;
        }

        .profile-pic {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid #fff;
            margin-right: 10px;
        }

        .user-details {
            display: flex;
            flex-direction: column;
        }

        .userid {
            font-weight: bold;
            font-size: 1.1rem;
            color: white;
        }

        .nickname {
            font-size: 0.9rem;
            color: #aaa;
        }

        .follow-button {
            background-color: transparent;
            color: white;
            border: 2px solid white;
            padding: 6px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: background-color 0.3s, color 0.3s;
            margin-left: 10px;
        }

        .follow-button:hover {
            background-color: white;
            color: black;
        }

        .text {
            margin: 6px 0;
            font-size: 1rem;
            cursor: pointer;
        }

        .text a {
            color: #38b1f7;
            text-decoration: none;
        }

        .time {
            font-size: 0.75rem;
            color: #777;
        }

        /* New interaction section styles */
        .new-interaction-section {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            align-items: center;
        }

        .interaction-item {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            user-select: none;
        }

        .interaction-icon {
            font-size: 30px;
            color: white;
            transition: color 0.3s;
        }

        .interaction-count {
            font-size: 1rem;
            font-weight: bold;
        }

        .like-icon.liked {
            color: #ff4d4d;
        }

        #sound-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #sound-indicator.show {
            opacity: 1;
        }

        #sound-indicator .material-icons {
            font-size: 32px;
            color: white;
        }

        /* Nav-bar styling */
        .tabs-container {
            display: flex;
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            /* background-color: #333; */
            border-radius: 25px;
            padding: 5px;
            z-index: 10;
        }

        .tab-button {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.5);
            font-size: 1.1rem;
            font-weight: bold;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .tab-button.active {
            background-color: rgba(0, 0, 0, 0.5);
            color: #fff;
            position: relative;
        }

        /* .tab-button.active::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 2px;
            background-color: #fff;
        } */

        #snaps-p {
            position: fixed;
            top: 5px;
            right: 5px;
            z-index: 10;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 700;
            font-size: 15px;
            letter-spacing: 1px;
            padding: 5px 12px;
            border-radius: 12px;
        }

        /* New Comment System CSS */
        .comments-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0;
            background: #1f1f1f;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            transition: height 0.3s ease-in-out;
            z-index: 1000;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .comments-container.open {
            height: 80vh;
        }

        .comments-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid #333;
        }

        .comments-title {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .close-comments {
            background: none;
            border: none;
            color: white;
            font-size: 2rem;
            cursor: pointer;
        }

        .comments-list {
            flex-grow: 1;
            padding: 15px;
            overflow-y: auto;
            flex-direction: column-reverse;
            position: relative;
        }

        #comments-loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            justify-content: center;
            align-items: center;
        }

        .comments-list-content {
            display: flex;
            flex-direction: column-reverse;
            gap: 12px;
        }

        .comment-item {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .comment-main-content {
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .comment-profile-pic {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
        }

        .comment-content {
            display: flex;
            flex-direction: column;
        }

        .comment-text-bubble {
            background: #2b2b2b;
            border-radius: 18px;
            padding: 10px 15px;
            max-width: 90%;
            word-wrap: break-word;
            display: inline-block;
        }

        .comment-user {
            font-weight: bold;
            font-size: 0.95rem;
            margin-right: 5px;
        }

        .comment-text {
            font-size: 0.95rem;
            color: #fff;
        }

        .comment-actions {
            display: flex;
            gap: 15px;
            margin-left: 10px;
        }

        .reply-button {
            margin-left: 30px;
            background: none;
            border: none;
            color: #aaa;
            font-size: 0.8rem;
            cursor: pointer;
            padding: 2px 5px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .replies-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-left: 42px;
            margin-top: 10px;
        }

        .replies-list .comment-item {
            margin-bottom: 0;
        }

        .comment-text a.reply-user,
        .comment-text a.hashtag {
            color: #38b1f7;
            text-decoration: none;
            font-weight: bold;
        }

        .comment-text a.reply-user:hover,
        .comment-text a.hashtag:hover {
            text-decoration: underline;
        }

        .comment-input-area {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            border-top: 1px solid #333;
        }

        .comment-input {
            flex-grow: 1;
            background: #333;
            border: none;
            border-radius: 20px;
            padding: 10px 15px;
            color: white;
            font-size: 1rem;
        }

        .send-comment-btn {
            background: none;
            border: none;
            color: #38b1f7;
            font-size: 1.5rem;
            margin-left: 10px;
            cursor: pointer;
        }

        /* New styles for comment likes */
        .comment-like-section {
            margin-right: 190px;
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            user-select: none;
            margin-left: auto; /* Sağ tərəfə hizalamaq üçün */
        }

        .comment-like-icon {
            font-size: 1.2rem;
            color: #aaa;
            transition: color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }

        .comment-like-icon.liked {
            color: #ff4d4d;
            transform: scale(1.1);
        }

        .comment-like-count {
            font-size: 0.8rem;
            color: #aaa;
            font-weight: normal;
        }

        /* Styles for the delete confirmation dialog */
        .delete-dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .delete-dialog {
            background: #2b2b2b;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            width: 80%;
            max-width: 300px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        }

        .delete-dialog h3 {
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 1.1rem;
        }

        .delete-dialog-buttons {
            display: flex;
            justify-content: space-around;
            gap: 10px;
        }

        .delete-dialog-buttons button {
            padding: 10px 20px;
            border-radius: 5px;
            border: none;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .delete-dialog-buttons #confirm-delete {
            background-color: #ff4d4d;
            color: white;
        }

        .delete-dialog-buttons #confirm-delete:hover {
            background-color: #d93636;
        }

        .delete-dialog-buttons #cancel-delete {
            background-color: #444;
            color: white;
        }

        .delete-dialog-buttons #cancel-delete:hover {
            background-color: #555;
        }
    </style>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=keyboard_arrow_down" />
</head>
<body>
    <div id="loader">
        <div class="spinner"></div>
    </div>
    <div id="app"></div>

    <div class="tabs-container">
        <button class="tab-button active" id="snaps-nav">Snaps</button>
        <button class="tab-button" id="friends-nav">Friends</button>
    </div>

    <div id="snaps-p">^_^</div>
    <div id="sound-indicator"><span class="material-icons">volume_up</span></div>

    <div id="comments-container" class="comments-container">
        <div class="comments-header">
            <span class="comments-title">Şərhlər</span>
            <button class="close-comments">&times;</button>
        </div>
        <div class="comments-list">
            <div id="comments-loader" style="display: none;">
                <div class="spinner"></div>
            </div>
            <div class="comments-list-content"></div>
        </div>
        <div class="comment-input-area">
            <input type="text" class="comment-input" placeholder="Şərh yazın..." />
            <button class="send-comment-btn material-icons">send</button>
        </div>
    </div>

    <div id="delete-dialog-overlay" class="delete-dialog-overlay">
        <div class="delete-dialog">
            <h3>Bu rəy silinsin?</h3>
            <div class="delete-dialog-buttons">
                <button id="confirm-delete">Bəli</button>
                <button id="cancel-delete">Ləğv et</button>
            </div>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
    <script>
        (function () {
            // Firebase configuration for reels
            const reelFirebaseConfig = {
                apiKey: "AIzaSyC6yWCYGtOkJoTOfZRoO8HGo-L_NKR9p5k",
                authDomain: "pasyak-reels.firebaseapp.com",
                projectId: "pasyak-reels",
                storageBucket: "pasyak-reels.firebasestorage.app",
                messagingSenderId: "635054499590",
                appId: "1:635054499590:web:7b1e9bc84f4b752317e087",
                measurementId: "G-FW0KJDLF4B"
            };
            const reelApp = firebase.initializeApp(reelFirebaseConfig, 'reelApp');
            const reelDb = reelApp.database();

            // Firebase configuration for user profiles
            const userFirebaseConfig = {
                apiKey: "AIzaSyBHRY6yGGT9qHV8df1OJXtmbQ7QxWu69ps",
                authDomain: "pasyak-user.firebaseapp.com",
                databaseURL: "https://pasyak-user-default-rtdb.firebaseio.com",
                projectId: "pasyak-user",
                storageBucket: "pasyak-user.firebasestorage.app",
                messagingSenderId: "898141218588",
                appId: "1:898141218588:web:f3477f39d96bceb2727cd9"
            };
            const userApp = firebase.initializeApp(userFirebaseConfig, 'userApp');
            const userDb = userApp.database();

            // Firebase configuration for follows
            const followsFirebaseConfig = {
                apiKey: "AIzaSyAZbtUw8id4yyXqrXtsf2FwuZmJ02qxit8",
                authDomain: "pasyak-follows.firebaseapp.com",
                databaseURL: "https://pasyak-follows-default-rtdb.firebaseio.com",
                projectId: "pasyak-follows",
                storageBucket: "pasyak-follows.firebasestorage.app",
                messagingSenderId: "571115478758",
                appId: "1:571115478758:web:9b45de3c9169083d9a2527",
                measurementId: "G-KHDDTM6FC9"
            };
            const followsApp = firebase.initializeApp(followsFirebaseConfig, 'followsApp');
            const followsDb = followsApp.database();

            // Firebase configuration for following
            const followingFirebaseConfig = {
                apiKey: "AIzaSyBA0gfZVLCnGV2Hli6BjEbq08SmLzFkshg",
                authDomain: "pasyak-following.firebaseapp.com",
                databaseURL: "https://pasyak-following-default-rtdb.firebaseio.com",
                projectId: "pasyak-following",
                storageBucket: "pasyak-following.firebasestorage.app",
                messagingSenderId: "538884111637",
                appId: "1:538884111637:web:c2c3532a1bda359aacbd1c"
            };
            const followingApp = firebase.initializeApp(followingFirebaseConfig, 'followingApp');
            const followingDb = followingApp.database();

            // Firebase configuration for comments (from user input)
            const commentsFirebaseConfig = {
                apiKey: "AIzaSyCqiOFuq6usZTZ4zsfd8LcCUdj1hP2j5cQ",
                authDomain: "reply-eb654.firebaseapp.com",
                databaseURL: "https://reply-eb654-default-rtdb.firebaseio.com",
                projectId: "reply-eb654",
                storageBucket: "reply-eb654.firebasestorage.app",
                messagingSenderId: "292801573334",
                appId: "1:292801573334:web:2486813d8fe45865d0f477"
            };
            const commentsApp = firebase.initializeApp(commentsFirebaseConfig, 'commentsApp');
            const commentsDb = commentsApp.database();

            // Firebase configuration for comment likes
            const commentLikesFirebaseConfig = {
                apiKey: "AIzaSyB3Ckrcg-Bw4SAY-OyZiAV-qwiJgT8pmfg",
                authDomain: "comment-55fc9.firebaseapp.com",
                databaseURL: "https://comment-55fc9-default-rtdb.firebaseio.com",
                projectId: "comment-55fc9",
                storageBucket: "comment-55fc9.firebasestorage.app",
                messagingSenderId: "968182843800",
                appId: "1:968182843800:web:d37989387f333c9705c3ed",
                measurementId: "G-NL2QXBSQFK"
            };
            const commentLikesApp = firebase.initializeApp(commentLikesFirebaseConfig, 'commentLikesApp');
            const commentLikesDb = commentLikesApp.database();


            // DOM elements
            const app = document.getElementById('app');
            const loader = document.getElementById('loader');
            const soundIndicator = document.getElementById('sound-indicator');
            const soundIcon = soundIndicator.querySelector('span');
            const commentsContainer = document.getElementById('comments-container');
            const closeCommentsBtn = document.querySelector('.close-comments');
            const commentsList = document.querySelector('.comments-list-content');
            const commentInput = document.querySelector('.comment-input');
            const sendCommentBtn = document.querySelector('.send-comment-btn');
            const commentsLoader = document.getElementById('comments-loader');
            const deleteDialogOverlay = document.getElementById('delete-dialog-overlay');
            const confirmDeleteBtn = document.getElementById('confirm-delete');
            const cancelDeleteBtn = document.getElementById('cancel-delete');
            const snapsNav = document.getElementById('snaps-nav');
            const friendsNav = document.getElementById('friends-nav');

            // URL parameters
            const userFromUrl = window.location.search.match(/user=([^&]+)/)?.[1];
            const currentUser = userFromUrl || "anonim";
            const cleanCurrentUser = currentUser.startsWith('@') ? currentUser.substring(1) : currentUser;

            // Get current user's full name and profile picture from user database
            let currentUserName = cleanCurrentUser;
            let currentUserProfilePic = 'https://via.placeholder.com/48';

            // Global variables
            let reels = [];
            let activeIndex = 0;
            let isAnimating = false;
            let allVideosSoundOn = true;
            let indicatorTimeout = null;
            let touchStartY = null;
            let activePostId = null;
            let activeCommentId = null;
            let commentAddedListenerAttached = false;
            let longPressTimer = null;
            let itemToDelete = null; // Store the comment/reply element to be deleted

            // Caches to avoid redundant Firebase calls
            const userProfileCache = {};
            const userNameCache = {};
            const userFollowStatusCache = {};

            /**
             * Fetches user profile picture from Firebase.
             * Caches the result to avoid repeated calls.
             * @param {string} username - The username to fetch profile picture for.
             * @returns {Promise<string>} - The URL of the profile picture or a placeholder.
             */
            async function fetchUserProfile(username) {
                const cleanUsername = username.startsWith('@') ? username.substring(1) : username;
                if (userProfileCache[cleanUsername]) {
                    return userProfileCache[cleanUsername];
                }
                try {
                    const snapshot = await userDb.ref(`Users/${cleanUsername}`).once('value');
                    const profileData = snapshot.val();
                    if (profileData) {
                        const parsedData = JSON.parse(profileData);
                        const profilePicUrl = parsedData[2].trim();
                        userProfileCache[cleanUsername] = profilePicUrl;
                        return profilePicUrl;
                    }
                } catch (e) {
                    console.error(`Error fetching profile for user ${cleanUsername}:`, e);
                }
                return 'https://via.placeholder.com/48';
            }

            /**
             * Fetches user's full name from Firebase.
             * Caches the result to avoid repeated calls.
             * @param {string} username - The username to fetch name for.
             * @returns {Promise<string>} - The full name of the user or the cleaned username.
             */
            async function fetchUserName(username) {
                const cleanUsername = username.startsWith('@') ? username.substring(1) : username;
                if (userNameCache[cleanUsername]) {
                    return userNameCache[cleanUsername];
                }
                try {
                    const snapshot = await userDb.ref(`Users/${cleanUsername}`).once('value');
                    const profileData = snapshot.val();
                    if (profileData) {
                        const parsedData = JSON.parse(profileData);
                        const name = parsedData[0];
                        userNameCache[cleanUsername] = name;
                        return name;
                    }
                } catch (e) {
                    console.error(`Error fetching name for user ${cleanUsername}:`, e);
                }
                return cleanUsername;
            }

            /**
             * Checks if the current user is following another user.
             * Caches the result for performance.
             * @param {string} reelUserNickname - The nickname of the user to check follow status for.
             * @returns {Promise<boolean>} - True if following, false otherwise.
             */
            async function isFollowing(reelUserNickname) {
                const cleanReelUserNickname = reelUserNickname.startsWith('@') ? reelUserNickname.substring(1) : reelUserNickname;
                const cleanCurrentUser = currentUser.startsWith('@') ? currentUser.substring(1) : currentUser;

                if (cleanReelUserNickname === cleanCurrentUser) {
                    return true;
                }

                if (userFollowStatusCache[cleanReelUserNickname] !== undefined) {
                    return userFollowStatusCache[cleanReelUserNickname];
                }

                try {
                    let snapshot = await followingDb.ref(cleanCurrentUser).child(cleanReelUserNickname).once('value');
                    if (!snapshot.exists()) {
                        snapshot = await followingDb.ref(cleanCurrentUser).child(`@${cleanReelUserNickname}`).once('value');
                    }
                    const isFollowed = snapshot.exists();
                    userFollowStatusCache[cleanReelUserNickname] = isFollowed;
                    return isFollowed;
                } catch (e) {
                    console.error("Error checking follow status:", e);
                    return false;
                }
            }

            /**
             * Creates a new reel element with all its components.
             * @param {object} post - The post data object.
             * @returns {object} - An object containing the created DOM elements.
             */
            function createReel(post) {
                const reelElement = document.createElement('div');
                reelElement.classList.add('reel');

                // Loader element
                const loader = document.createElement('div');
                loader.classList.add('reel-loader');
                reelElement.appendChild(loader);

                // Video element
                const video = document.createElement('video');
                video.muted = true;
                video.autoplay = true;
                video.loop = true;
                video.playsInline = true;
                video.preload = 'auto';
                video.src = post.video.trim(); // Trim whitespace from the video URL
                reelElement.appendChild(video);

                // Overlay container for text and icons
                const overlay = document.createElement('div');
                overlay.classList.add('overlay');
                reelElement.appendChild(overlay);

                // Profile info section
                const profileInfo = document.createElement('div');
                profileInfo.classList.add('profile-info');
                overlay.appendChild(profileInfo);

                // Profile picture
                const profilePic = document.createElement('img');
                profilePic.classList.add('profile-pic');
                profilePic.src = post.profile || 'https://via.placeholder.com/48';
                profileInfo.appendChild(profilePic);

                const userInfo = document.createElement('div');
                userInfo.classList.add('user-info');
                profileInfo.appendChild(userInfo);

                const userDetails = document.createElement('div');
                userDetails.classList.add('user-details');
                userInfo.appendChild(userDetails);

                // User ID
                const userid = document.createElement('div');
                userid.classList.add('userid');
                userid.textContent = post.user;
                userDetails.appendChild(userid);

                // Nickname
                const nickname = document.createElement('div');
                nickname.classList.add('nickname');
                nickname.textContent = post.nickname;
                userDetails.appendChild(nickname);

                // Follow button
                const followButton = document.createElement('button');
                followButton.classList.add('follow-button');
                followButton.textContent = 'Follow';
                followButton.style.display = post.isFollowed ? 'none' : 'block';
                userInfo.appendChild(followButton);

                // Reel text
                const text = document.createElement('div');
                text.classList.add('text');
                const formattedText = formatText(post.text);
                text.innerHTML = formattedText;
                overlay.appendChild(text);

                // Time
                const time = document.createElement('div');
                time.classList.add('time');
                time.textContent = post.time;
                overlay.appendChild(time);

                // New interaction section
                const newInteractionSection = document.createElement('div');
                newInteractionSection.classList.add('new-interaction-section');
                overlay.appendChild(newInteractionSection);

                // Like icon and count
                const likeItem = document.createElement('div');
                likeItem.classList.add('interaction-item');
                newInteractionSection.appendChild(likeItem);

                const likeIcon = document.createElement('span');
                likeIcon.classList.add('material-icons', 'interaction-icon', 'like-icon');
                likeIcon.textContent = 'favorite_border';
                if (post.isLiked) {
                    likeIcon.classList.add('liked');
                    likeIcon.textContent = 'favorite';
                }
                likeItem.appendChild(likeIcon);

                const likeCount = document.createElement('span');
                likeCount.classList.add('interaction-count');
                likeCount.textContent = post.likes || 0;
                likeItem.appendChild(likeCount);

                // Comment icon and count
                const commentItem = document.createElement('div');
                commentItem.classList.add('interaction-item', 'comment-item');
                newInteractionSection.appendChild(commentItem);

                const commentIcon = document.createElement('span');
                commentIcon.classList.add('material-icons', 'interaction-icon');
                commentIcon.textContent = 'comment';
                commentItem.appendChild(commentIcon);

                const commentCountElement = document.createElement('span');
                commentCountElement.classList.add('interaction-count', 'comment-count');
                commentCountElement.textContent = 0;
                commentItem.appendChild(commentCountElement);

                // Share icon
                const shareItem = document.createElement('div');
                shareItem.classList.add('interaction-item');
                newInteractionSection.appendChild(shareItem);

                const shareIcon = document.createElement('span');
                shareIcon.classList.add('material-icons', 'interaction-icon');
                shareIcon.textContent = 'share';
                shareItem.appendChild(shareIcon);

                // Event Listeners
                video.addEventListener('loadeddata', () => {
                    video.style.display = 'block';
                    loader.style.display = 'none';
                    if (activeIndex === reels.findIndex(r => r.element === reelElement)) {
                        video.play().catch(e => console.error("Video play failed:", e));
                    }
                });

                video.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (video.paused) {
                        video.play();
                    } else {
                        video.pause();
                    }
                });

                likeItem.addEventListener('click', () => {
                    toggleLike(post.id);
                });

                commentItem.addEventListener('click', () => {
                    openComments(post.id);
                });

                followButton.addEventListener('click', () => {
                    toggleFollow(post.nickname);
                });

                return { element: reelElement, video, likeIcon, likeCount, followButton, commentCountElement, userNickname: post.nickname, postId: post.id };
            }

            /**
             * Toggles the like status of a reel.
             * @param {string} postId - The ID of the reel to like/unlike.
             */
            async function toggleLike(postId) {
                const likeRef = reelDb.ref(`likes/${postId}`);
                const likeUserRef = likeRef.child('users');

                const snapshot = await likeUserRef.once('value');
                const users = snapshot.val() || {};
                const isLiked = users[currentUser];

                if (isLiked) {
                    // Unlike
                    await likeUserRef.child(currentUser).remove();
                    await likeRef.child('count').transaction(currentCount => (currentCount || 0) - 1);
                } else {
                    // Like
                    await likeUserRef.child(currentUser).set(true);
                    await likeRef.child('count').transaction(currentCount => (currentCount || 0) + 1);
                }
            }

            /**
             * Toggles the follow status of a user.
             * @param {string} userToFollowNickname - The nickname of the user to follow/unfollow.
             */
            async function toggleFollow(userToFollowNickname) {
                const cleanUserToFollow = userToFollowNickname.startsWith('@') ? userToFollowNickname.substring(1) : userToFollowNickname;
                const cleanCurrentUser = currentUser.startsWith('@') ? currentUser.substring(1) : currentUser;

                const followingRef = followingDb.ref(cleanCurrentUser).child(cleanUserToFollow);

                const snapshot = await followingRef.once('value');
                if (snapshot.exists()) {
                    // Unfollow
                    await followingRef.remove();
                } else {
                    // Follow
                    await followingRef.set(true);
                }
            }


            /**
             * Formats a raw text string, replacing hashtags and mentions with links.
             * @param {string} text - The raw text string.
             * @returns {string} - The formatted HTML string.
             */
            function formatText(text) {
                if (!text) return '';
                // Replace hashtags
                let formatted = text.replace(/(#\w+)/g, '<a href="#">$1</a>');
                // Replace mentions
                formatted = formatted.replace(/(@\w+)/g, '<a href="#">$1</a>');
                return formatted;
            }

            /**
             * Handles touch events for vertical scrolling.
             * @param {TouchEvent} e - The touch event object.
             */
            function handleTouchStart(e) {
                touchStartY = e.touches[0].clientY;
                if (reels[activeIndex] && reels[activeIndex].video) {
                    reels[activeIndex].video.pause();
                }
            }

            /**
             * Handles touch move events for vertical scrolling.
             * @param {TouchEvent} e - The touch event object.
             */
            function handleTouchMove(e) {
                if (isAnimating || touchStartY === null) return;
                const touchMoveY = e.touches[0].clientY;
                const deltaY = touchMoveY - touchStartY;

                // Stop scrolling if the video is not muted
                const activeVideo = reels[activeIndex].video;
                if (activeVideo && !activeVideo.muted) {
                    e.preventDefault();
                    return;
                }

                if (Math.abs(deltaY) > 50) {
                    if (deltaY > 0) {
                        // Swiping down
                        if (activeIndex > 0) {
                            showNextReel(-1);
                        }
                    } else {
                        // Swiping up
                        if (activeIndex < reels.length - 1) {
                            showNextReel(1);
                        }
                    }
                    touchStartY = null; // Reset for the next swipe
                }
            }

            /**
             * Handles touch end events.
             * @param {TouchEvent} e - The touch event object.
             */
            function handleTouchEnd() {
                if (reels[activeIndex] && reels[activeIndex].video) {
                    reels[activeIndex].video.play().catch(e => console.error("Video play failed on touch end:", e));
                }
                touchStartY = null;
            }

            /**
             * Switches to the next or previous reel with a sliding animation.
             * @param {number} direction - 1 for next, -1 for previous.
             */
            function showNextReel(direction) {
                if (isAnimating) return;
                isAnimating = true;

                const prevIndex = activeIndex;
                activeIndex += direction;

                if (activeIndex < 0) {
                    activeIndex = 0;
                    isAnimating = false;
                    return;
                }
                if (activeIndex >= reels.length) {
                    activeIndex = reels.length - 1;
                    isAnimating = false;
                    return;
                }

                const currentReel = reels[prevIndex];
                const nextReel = reels[activeIndex];

                currentReel.element.style.transform = `translateY(${-direction * 100}%)`;
                currentReel.element.style.opacity = '0';

                nextReel.element.classList.add('active');
                nextReel.element.style.transform = 'translateY(0)';
                nextReel.element.style.opacity = '1';

                currentReel.video.pause();
                currentReel.video.currentTime = 0;
                currentReel.video.style.display = 'none';
                currentReel.loader.style.display = 'block';

                playActiveVideo(activeIndex);

                setTimeout(() => {
                    currentReel.element.classList.remove('active');
                    isAnimating = false;
                }, 500); // Duration of the CSS transition
            }

            // Keyboard navigation
            window.addEventListener('keydown', (e) => {
                if (isAnimating) return;
                if (e.key === 'ArrowDown' && activeIndex < reels.length - 1) {
                    showNextReel(1);
                } else if (e.key === 'ArrowUp' && activeIndex > 0) {
                    showNextReel(-1);
                }
            });

            // Handle mouse wheel for vertical scrolling
            let lastScrollTime = 0;
            const scrollThreshold = 200; // milliseconds
            window.addEventListener('wheel', (e) => {
                const now = Date.now();
                if (now - lastScrollTime < scrollThreshold || isAnimating) {
                    return;
                }
                lastScrollTime = now;

                if (e.deltaY > 0) {
                    // Scrolling down
                    if (activeIndex < reels.length - 1) {
                        showNextReel(1);
                    }
                } else if (e.deltaY < 0) {
                    // Scrolling up
                    if (activeIndex > 0) {
                        showNextReel(-1);
                    }
                }
            });

            // Sound toggle on video click
            window.addEventListener('click', (e) => {
                const activeVideo = reels[activeIndex]?.video;
                if (!activeVideo || commentsContainer.classList.contains('open') ||
                    e.target.closest('.overlay') || e.target.closest('.tabs-container')) {
                    return;
                }

                const prevMutedState = activeVideo.muted;
                activeVideo.muted = !prevMutedState;
                allVideosSoundOn = !activeVideo.muted;
                showSoundIndicator(!allVideosSoundOn);
            });


            /**
             * Shuffles an array randomly.
             * @param {Array} array - The array to shuffle.
             * @returns {Array} - The shuffled array.
             */
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            // Real-time listener for reel likes (updates like count and icon for reels)
            reelDb.ref('likes').on('value', (snapshot) => {
                const likesData = snapshot.val() || {};
                reels.forEach(reel => {
                    const postLikes = likesData[reel.postId] || {};
                    const likedByUser = postLikes.users && postLikes.users[currentUser];
                    if (likedByUser) {
                        reel.likeIcon.classList.add('liked');
                        reel.likeIcon.textContent = 'favorite';
                    } else {
                        reel.likeIcon.classList.remove('liked');
                        reel.likeIcon.textContent = 'favorite_border';
                    }
                    const likeCount = postLikes.count || 0;
                    reel.likeCount.textContent = likeCount;
                });
            });

            /**
             * Initializes the main application by fetching reels data, user profiles,
             * and rendering the reels.
             */
            async function initializeApp() {
                loader.style.display = 'flex';
                currentUserName = await fetchUserName(cleanCurrentUser);
                currentUserProfilePic = await fetchUserProfile(cleanCurrentUser);

                await displayReels('snaps');
                loader.style.display = 'none';

                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.get('reply') === 'true' && urlParams.get('post')) {
                    const postIdFromUrl = urlParams.get('post');
                    const postIndex = reels.findIndex(r => r.postId === postIdFromUrl);
                    if (postIndex !== -1) {
                        setActiveReel(postIndex);
                        openComments(postIdFromUrl);
                    }
                }
            }


            async function displayReels(mode) {
                if(isAnimating) return;
                isAnimating = true;

                // Pause any playing video and clear the screen
                if(reels[activeIndex] && reels[activeIndex].video) {
                    reels[activeIndex].video.pause();
                }
                while (app.firstChild) {
                    app.removeChild(app.firstChild);
                }
                reels = [];
                activeIndex = 0;

                const postsData = await reelDb.ref('reels').once('value').then(snapshot => snapshot.val() || {});
                const likesData = await reelDb.ref('likes').once('value').then(snap => snap.val() || {});
                let postIds = Object.keys(postsData);

                if (mode === 'friends') {
                    const followingSnapshot = await followingDb.ref(cleanCurrentUser).once('value');
                    const followingUsers = Object.keys(followingSnapshot.val() || {});
                    postIds = postIds.filter(id => {
                        const post = JSON.parse(postsData[id]);
                        const cleanNickname = post.nickname.startsWith('@') ? post.nickname.substring(1) : post.nickname;
                        return followingUsers.includes(cleanNickname) || followingUsers.includes(`@${cleanNickname}`);
                    });
                }

                postIds = shuffleArray(postIds);

                const loadedReels = [];
                for (const postId of postIds) {
                    let post;
                    try {
                        post = JSON.parse(postsData[postId]);
                    } catch (e) {
                        console.error(`Error parsing JSON for reel ID ${postId}:`, e);
                        continue;
                    }

                    const profilePicUrl = await fetchUserProfile(post.nickname);
                    post.profile = profilePicUrl;

                    const isFollowed = await isFollowing(post.nickname);
                    const isLiked = likesData[postId] && likesData[postId].users && likesData[postId].users[currentUser];
                    loadedReels.push({ id: postId, isFollowed, isLiked, ...post });
                }

                loadedReels.forEach(post => {
                    const newReel = createReel(post);
                    app.appendChild(newReel.element);
                    reels.push(newReel);

                    reelDb.ref(`likes/${post.id}/count`).once('value').then(likeSnap => {
                        const count = likeSnap.val() || 0;
                        newReel.likeCount.textContent = count;
                    });

                    commentsDb.ref(`comments/${post.id}`).on('value', async (snap) => {
                        let totalComments = 0;
                        const commentsData = snap.val();
                        if (commentsData) {
                            for (const commentId in commentsData) {
                                totalComments++; // Count the main comment
                                if (commentsData[commentId].replies) {
                                    totalComments += Object.keys(commentsData[commentId].replies).length; // Add reply count
                                }
                            }
                        }
                        newReel.commentCountElement.textContent = totalComments;
                    });
                });

                if (reels.length > 0) {
                    activeIndex = 0;
                    const activeReel = reels[activeIndex];
                    activeReel.element.classList.add('active');
                    activeReel.element.style.transform = 'translateY(0)';
                    activeReel.element.style.opacity = '1';

                    playActiveVideo(activeIndex);
                    preloadVideos();
                }

                isAnimating = false;
            }

            initializeApp();

            // Nav-bar event listeners
            snapsNav.addEventListener('click', () => {
                snapsNav.classList.add('active');
                friendsNav.classList.remove('active');
                displayReels('snaps');
            });

            friendsNav.addEventListener('click', () => {
                friendsNav.classList.add('active');
                snapsNav.classList.remove('active');
                displayReels('friends');
            });

            // Real-time update for follow button visibility
            followingDb.ref(cleanCurrentUser).on('value', async (snapshot) => {
                const followingData = snapshot.val() || {};
                const followingUsers = Object.keys(followingData);

                for (const user in userFollowStatusCache) {
                    userFollowStatusCache[user] = followingUsers.includes(user);
                }

                reels.forEach(reel => {
                    const cleanNickname = reel.userNickname.startsWith('@') ? reel.userNickname.substring(1) : reel.userNickname;
                    const followButton = reel.followButton;
                    if (followButton) {
                        const cleanPostNickname = reel.userNickname.startsWith('@') ? reel.userNickname.substring(1) : reel.userNickname;
                        if (cleanPostNickname === cleanCurrentUser || followingUsers.includes(cleanNickname) || followingUsers.includes(`@${cleanNickname}`)) {
                            followButton.style.display = 'none';
                        } else {
                            followButton.style.display = 'block';
                        }
                    }
                });
            });

            /**
             * Shows the sound indicator (volume on/off icon).
             * @param {boolean} muted - True if sound is muted, false otherwise.
             */
            function showSoundIndicator(muted) {
                clearTimeout(indicatorTimeout);
                soundIcon.textContent = muted ? 'volume_off' : 'volume_up';
                soundIndicator.classList.add('show');
                indicatorTimeout = setTimeout(() => {
                    soundIndicator.classList.remove('show');
                }, 1000);
            }

            /** Preloads videos for smoother playback. */
            function preloadVideos() {
                for (let i = 0; i < reels.length; i++) {
                    const video = reels[i].video;
                    video.preload = 'auto';
                }
            }

            /**
             * Plays the video of the currently active reel.
             * Handles autoplay and muted states.
             * @param {number} index - The index of the active reel.
             */
            function playActiveVideo(index) {
                const reel = reels[index];
                if (reel && reel.video) {
                    reel.video.addEventListener('loadeddata', () => {
                        reel.video.style.display = 'block';
                        if(reel.loader) reel.loader.style.display = 'none';
                        reel.video.muted = !allVideosSoundOn;
                        reel.video.play().catch(e => {
                            console.error("Video play failed:", e);
                            reel.video.style.display = 'none';
                        });
                    });
                    // Immediately try to play if already loaded
                    if (reel.video.readyState >= 3) {
                        reel.video.style.display = 'block';
                        if(reel.loader) reel.loader.style.display = 'none';
                        reel.video.muted = !allVideosSoundOn;
                        reel.video.play().catch(e => {
                            console.error("Video play failed:", e);
                            reel.video.style.display = 'none';
                        });
                    }
                }
            }

            /**
             * Sets the active reel by index.
             * @param {number} index - The index of the reel to set as active.
             */
            function setActiveReel(index) {
                if (isAnimating) return;
                isAnimating = true;

                const currentReel = reels[activeIndex];
                if (currentReel) {
                    currentReel.element.classList.remove('active');
                    currentReel.video.pause();
                    currentReel.video.currentTime = 0;
                    currentReel.video.style.display = 'none';
                    if(currentReel.loader) currentReel.loader.style.display = 'block';
                }

                activeIndex = index;
                const nextReel = reels[activeIndex];

                if (nextReel) {
                    nextReel.element.classList.add('active');
                    playActiveVideo(activeIndex);
                }

                isAnimating = false;
            }


            // Mobile touch event listeners
            app.addEventListener('touchstart', handleTouchStart);
            app.addEventListener('touchmove', handleTouchMove);
            app.addEventListener('touchend', handleTouchEnd);


            // Comments section functionality
            closeCommentsBtn.addEventListener('click', () => {
                commentsContainer.classList.remove('open');
                if (reels[activeIndex] && reels[activeIndex].video) {
                    reels[activeIndex].video.play().catch(e => console.error("Video play failed on comment close:", e));
                }
                document.body.style.overflow = 'hidden';
            });

            async function openComments(postId) {
                activePostId = postId;
                commentsContainer.classList.add('open');
                if (reels[activeIndex] && reels[activeIndex].video) {
                    reels[activeIndex].video.pause();
                }
                document.body.style.overflow = 'hidden';
                commentInput.focus();
                await fetchAndDisplayComments(postId);
            }

            sendCommentBtn.addEventListener('click', sendComment);
            commentInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    sendComment();
                }
            });

            async function sendComment() {
                const commentText = commentInput.value.trim();
                if (!commentText) return;

                const commentsRef = commentsDb.ref(`comments/${activePostId}`);
                const newCommentRef = commentsRef.push();
                const commentId = newCommentRef.key;

                const newComment = {
                    user: currentUser,
                    text: commentText,
                    time: new Date().toISOString(),
                    likes: 0,
                };

                await newCommentRef.set(newComment);
                commentInput.value = '';

                // Add real-time listener for the new comment's likes
                addCommentLikeListener(commentId);
            }

            async function fetchAndDisplayComments(postId) {
                commentsList.innerHTML = '';
                commentsLoader.style.display = 'flex';
                const commentsRef = commentsDb.ref(`comments/${postId}`);

                // Attach real-time listeners for all comments
                if (!commentAddedListenerAttached) {
                    commentsRef.on('child_added', (snapshot) => {
                        const commentId = snapshot.key;
                        const commentData = snapshot.val();
                        displayComment(commentId, commentData, postId);
                        addCommentLikeListener(commentId);
                    });
                    commentsRef.on('child_removed', (snapshot) => {
                        const commentId = snapshot.key;
                        const commentElement = document.querySelector(`.comment-item[data-comment-id="${commentId}"]`);
                        if (commentElement) {
                            commentElement.remove();
                        }
                    });
                    commentAddedListenerAttached = true;
                }

                const snapshot = await commentsRef.once('value');
                const commentsData = snapshot.val();
                if (commentsData) {
                    // This is to display existing comments on open
                    const commentsFragment = document.createDocumentFragment();
                    for (const commentId in commentsData) {
                        const commentData = commentsData[commentId];
                        const commentElement = await createCommentElement(commentId, commentData, postId);
                        commentsFragment.appendChild(commentElement);
                    }
                    commentsList.innerHTML = ''; // Clear and re-populate to maintain order
                    commentsList.appendChild(commentsFragment);
                }
                commentsLoader.style.display = 'none';
            }

            async function createCommentElement(commentId, commentData, postId, isReply = false, parentId = null) {
                const commentItem = document.createElement('div');
                commentItem.classList.add('comment-item');
                commentItem.dataset.commentId = commentId;
                if (isReply) {
                    commentItem.dataset.parentId = parentId;
                }

                const commentMainContent = document.createElement('div');
                commentMainContent.classList.add('comment-main-content');

                const profilePicUrl = await fetchUserProfile(commentData.user);
                const profilePic = document.createElement('img');
                profilePic.classList.add('comment-profile-pic');
                profilePic.src = profilePicUrl;
                commentMainContent.appendChild(profilePic);

                const commentContent = document.createElement('div');
                commentContent.classList.add('comment-content');

                const textBubble = document.createElement('div');
                textBubble.classList.add('comment-text-bubble');
                const userSpan = document.createElement('span');
                userSpan.classList.add('comment-user');
                userSpan.textContent = commentData.user.startsWith('@') ? commentData.user : `@${commentData.user}`;
                const textSpan = document.createElement('span');
                textSpan.classList.add('comment-text');
                textSpan.innerHTML = formatText(commentData.text);

                textBubble.appendChild(userSpan);
                textBubble.appendChild(textSpan);
                commentContent.appendChild(textBubble);

                commentMainContent.appendChild(commentContent);
                commentItem.appendChild(commentMainContent);

                const commentActions = document.createElement('div');
                commentActions.classList.add('comment-actions');
                commentContent.appendChild(commentActions);

                if (!isReply) {
                    const replyBtn = document.createElement('button');
                    replyBtn.classList.add('reply-button');
                    replyBtn.innerHTML = `<span>Cevabla</span>`;
                    replyBtn.onclick = () => {
                        commentInput.placeholder = `Cevapla: @${commentData.user}`;
                        commentInput.focus();
                        commentInput.onkeydown = (e) => {
                            if (e.key === 'Enter') {
                                sendReply(commentId, commentData.user);
                            }
                        };
                        sendCommentBtn.onclick = () => sendReply(commentId, commentData.user);
                    };
                    commentActions.appendChild(replyBtn);
                }

                const likeSection = document.createElement('div');
                likeSection.classList.add('comment-like-section');
                likeSection.dataset.commentId = commentId;
                if (isReply) {
                    likeSection.dataset.parentId = parentId;
                }
                commentActions.appendChild(likeSection);

                const likeIcon = document.createElement('span');
                likeIcon.classList.add('material-icons', 'comment-like-icon');
                likeIcon.textContent = 'favorite_border';
                likeSection.appendChild(likeIcon);

                const likeCount = document.createElement('span');
                likeCount.classList.add('comment-like-count');
                likeCount.textContent = commentData.likes || 0;
                likeSection.appendChild(likeCount);

                const likeRef = commentLikesDb.ref(`${postId}/${isReply ? `${parentId}/replies/` : ''}${commentId}`);
                likeRef.on('value', (snapshot) => {
                    const likes = snapshot.val() || { count: 0 };
                    likeCount.textContent = likes.count;
                    if (likes.users && likes.users[currentUser]) {
                        likeIcon.classList.add('liked');
                        likeIcon.textContent = 'favorite';
                    } else {
                        likeIcon.classList.remove('liked');
                        likeIcon.textContent = 'favorite_border';
                    }
                });

                likeSection.onclick = () => toggleCommentLike(postId, commentId, isReply, parentId);

                // Long press for delete
                commentItem.addEventListener('touchstart', (e) => {
                    longPressTimer = setTimeout(() => {
                        itemToDelete = commentItem;
                        showDeleteDialog();
                    }, 500);
                });
                commentItem.addEventListener('touchend', () => {
                    clearTimeout(longPressTimer);
                });
                commentItem.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    itemToDelete = commentItem;
                    showDeleteDialog();
                });

                // Display replies
                if (commentData.replies && !isReply) {
                    const repliesList = document.createElement('div');
                    repliesList.classList.add('replies-list');
                    commentContent.appendChild(repliesList);
                    for (const replyId in commentData.replies) {
                        const replyData = commentData.replies[replyId];
                        const replyElement = await createCommentElement(replyId, replyData, postId, true, commentId);
                        repliesList.appendChild(replyElement);
                    }
                }

                return commentItem;
            }

            async function sendReply(parentId, parentUser) {
                const replyText = commentInput.value.trim();
                if (!replyText) return;

                const replyRef = commentsDb.ref(`comments/${activePostId}/${parentId}/replies`).push();
                const replyId = replyRef.key;

                const newReply = {
                    user: currentUser,
                    text: replyText,
                    time: new Date().toISOString(),
                    likes: 0
                };

                await replyRef.set(newReply);
                commentInput.value = '';
                commentInput.placeholder = 'Şərh yazın...';
                sendCommentBtn.onclick = sendComment; // Reset send button handler
                commentInput.onkeydown = (e) => {
                    if (e.key === 'Enter') {
                        sendComment();
                    }
                };
            }

            async function toggleCommentLike(postId, commentId, isReply, parentId) {
                const likesPath = `${postId}/${isReply ? `${parentId}/replies/` : ''}${commentId}`;
                const likesRef = commentLikesDb.ref(likesPath);
                const likeUserRef = likesRef.child('users');

                const snapshot = await likeUserRef.once('value');
                const users = snapshot.val() || {};
                const isLiked = users[currentUser];

                if (isLiked) {
                    await likeUserRef.child(currentUser).remove();
                    await likesRef.child('count').transaction(currentCount => (currentCount || 0) - 1);
                } else {
                    await likeUserRef.child(currentUser).set(true);
                    await likesRef.child('count').transaction(currentCount => (currentCount || 0) + 1);
                }
            }

            function showDeleteDialog() {
                deleteDialogOverlay.style.display = 'flex';
            }

            function hideDeleteDialog() {
                deleteDialogOverlay.style.display = 'none';
                itemToDelete = null;
            }

            async function deleteItem() {
                if (!itemToDelete) return;

                const commentId = itemToDelete.dataset.commentId;
                const parentId = itemToDelete.dataset.parentId;

                try {
                    if (parentId) {
                        // It's a reply
                        const replyRef = commentsDb.ref(`comments/${activePostId}/${parentId}/replies/${commentId}`);
                        await replyRef.remove();
                    } else {
                        // It's a main comment
                        const commentRef = commentsDb.ref(`comments/${activePostId}/${commentId}`);
                        await commentRef.remove();
                    }
                    console.log("Deletion successful.");
                    itemToDelete.remove();
                } catch (e) {
                    console.error("Deletion failed:", e);
                } finally {
                    hideDeleteDialog();
                }
            }

            // Event listeners for the delete dialog buttons
            confirmDeleteBtn.addEventListener('click', deleteItem);
            cancelDeleteBtn.addEventListener('click', hideDeleteDialog);
            deleteDialogOverlay.addEventListener('click', (e) => {
                if (e.target.id === 'delete-dialog-overlay') {
                    hideDeleteDialog();
                }
            });
        })();
    </script>
</body>
</html>
